// Service Worker para notificaciones push
// Este archivo maneja las notificaciones push cuando la aplicaci√≥n est√° cerrada

const CACHE_NAME = 'gestor-tc-v2';
const STATIC_CACHE = 'gestor-tc-static-v2';
const DYNAMIC_CACHE = 'gestor-tc-dynamic-v2';
const DATA_CACHE = 'gestor-tc-data-v2';

// Recursos est√°ticos que siempre deben estar en cache
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/manifest.json',
  '/assets/icons/icon-72x72.png',
  '/assets/icons/icon-96x96.png',
  '/assets/icons/icon-128x128.png',
  '/assets/icons/icon-144x144.png',
  '/assets/icons/icon-152x152.png',
  '/assets/icons/icon-192x192.png',
  '/assets/icons/icon-384x384.png',
  '/assets/icons/icon-512x512.png',
  '/assets/icons/badge-72x72.png'
];

// Patrones de URLs para cache din√°mico
const CACHE_PATTERNS = {
  api: /\/api\//,
  assets: /\.(js|css|png|jpg|jpeg|svg|woff|woff2|ttf|eot)$/,
  angular: /\.(js|css)$/
};

// URLs que nunca deben ser cacheadas
const NEVER_CACHE = [
  '/sw.js',
  '/ngsw.json',
  '/ngsw-worker.js'
];

// Instalaci√≥n del Service Worker
self.addEventListener('install', (event) => {
  console.log('Service Worker: Instalando v2...');
  event.waitUntil(
    Promise.all([
      // Cache de recursos est√°ticos
      caches.open(STATIC_CACHE).then(cache => {
        console.log('Service Worker: Cacheando recursos est√°ticos');
        return cache.addAll(STATIC_ASSETS);
      }),
      // Inicializar otros caches
      caches.open(DYNAMIC_CACHE),
      caches.open(DATA_CACHE)
    ])
    .then(() => {
      console.log('Service Worker: Instalaci√≥n completada');
      return self.skipWaiting(); // Activar inmediatamente
    })
    .catch((error) => {
      console.error('Service Worker: Error durante la instalaci√≥n:', error);
    })
  );
});

// Activaci√≥n del Service Worker
self.addEventListener('activate', (event) => {
  console.log('Service Worker: Activando v2...');
  event.waitUntil(
    Promise.all([
      // Limpiar caches antiguos
      caches.keys().then((cacheNames) => {
        const validCaches = [STATIC_CACHE, DYNAMIC_CACHE, DATA_CACHE];
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (!validCaches.includes(cacheName)) {
              console.log('Service Worker: Eliminando cache antiguo:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      }),
      // Tomar control de todos los clientes
      self.clients.claim()
    ])
    .then(() => {
      console.log('Service Worker: Activado y listo v2');
    })
    .catch((error) => {
      console.error('Service Worker: Error durante la activaci√≥n:', error);
    })
  );
});

// Interceptar peticiones de red
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Filtrar esquemas no soportados (chrome-extension, moz-extension, etc.)
  if (!url.protocol.startsWith('http')) {
    return;
  }
  
  // No cachear URLs en la lista negra
  if (NEVER_CACHE.some(pattern => url.pathname.includes(pattern))) {
    return;
  }
  
  event.respondWith(handleFetch(request));
});

/**
 * Maneja las peticiones fetch con diferentes estrategias seg√∫n el tipo de recurso
 */
async function handleFetch(request) {
  const url = new URL(request.url);
  
  try {
    // Estrategia para recursos est√°ticos (Cache First)
    if (CACHE_PATTERNS.assets.test(url.pathname) || STATIC_ASSETS.includes(url.pathname)) {
      return await cacheFirst(request, STATIC_CACHE);
    }
    
    // Estrategia para APIs (Network First con fallback a cache)
    if (CACHE_PATTERNS.api.test(url.pathname)) {
      return await networkFirst(request, DATA_CACHE);
    }
    
    // Estrategia para navegaci√≥n (Network First con fallback a index.html)
    if (request.mode === 'navigate') {
      return await navigationHandler(request);
    }
    
    // Estrategia por defecto (Stale While Revalidate)
    return await staleWhileRevalidate(request, DYNAMIC_CACHE);
    
  } catch (error) {
    console.error('Error en handleFetch:', error);
    return await fallbackResponse(request);
  }
}

/**
 * Estrategia Cache First: Busca primero en cache, luego en red
 */
async function cacheFirst(request, cacheName) {
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  
  const networkResponse = await fetch(request);
  if (networkResponse.ok) {
    const cache = await caches.open(cacheName);
    cache.put(request, networkResponse.clone());
  }
  
  return networkResponse;
}

/**
 * Estrategia Network First: Intenta red primero, fallback a cache
 */
async function networkFirst(request, cacheName) {
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open(cacheName);
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    throw error;
  }
}

/**
 * Estrategia Stale While Revalidate: Devuelve cache y actualiza en background
 */
async function staleWhileRevalidate(request, cacheName) {
  const cachedResponse = await caches.match(request);
  
  const fetchPromise = fetch(request).then(networkResponse => {
    if (networkResponse.ok) {
      // Clonar la respuesta antes de usarla para evitar el error "Response body is already used"
      const responseClone = networkResponse.clone();
      const cache = caches.open(cacheName);
      cache.then(c => c.put(request, responseClone));
    }
    return networkResponse;
  }).catch(() => null);
  
  return cachedResponse || await fetchPromise;
}

/**
 * Maneja las peticiones de navegaci√≥n
 */
async function navigationHandler(request) {
  try {
    const networkResponse = await fetch(request);
    return networkResponse;
  } catch (error) {
    const cachedResponse = await caches.match('/index.html');
    return cachedResponse || await fallbackResponse(request);
  }
}

/**
 * Respuesta de fallback cuando todo falla
 */
async function fallbackResponse(request) {
  if (request.mode === 'navigate') {
    return new Response(
      `<!DOCTYPE html>
      <html>
        <head>
          <title>Gestor TC - Sin conexi√≥n</title>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
            .offline { color: #666; }
          </style>
        </head>
        <body>
          <div class="offline">
            <h1>Sin conexi√≥n</h1>
            <p>No se puede cargar la p√°gina. Verifica tu conexi√≥n a internet.</p>
            <button onclick="window.location.reload()">Reintentar</button>
          </div>
        </body>
      </html>`,
      {
        status: 200,
        statusText: 'OK',
        headers: { 'Content-Type': 'text/html' }
      }
    );
  }
  
  return new Response('Sin conexi√≥n', {
    status: 503,
    statusText: 'Service Unavailable'
  });
}

// Manejar notificaciones push recibidas
self.addEventListener('push', (event) => {
  console.log('Service Worker: Push recibido:', event);
  
  let notificationData = {
    title: 'üí≥ Gestor TC',
    body: 'Tienes una nueva notificaci√≥n',
    icon: '/assets/icons/icon-192x192.png',
    badge: '/assets/icons/badge-72x72.png',
    tag: 'default',
    data: {
      url: '/'
    }
  };

  // Procesar datos del push si existen
  if (event.data) {
    try {
      const pushData = event.data.json();
      notificationData = {
        ...notificationData,
        ...pushData
      };
    } catch (error) {
      console.error('Service Worker: Error parseando datos push:', error);
      notificationData.body = event.data.text() || notificationData.body;
    }
  }

  // Mostrar la notificaci√≥n
  event.waitUntil(
    self.registration.showNotification(notificationData.title, {
      body: notificationData.body,
      icon: notificationData.icon,
      badge: notificationData.badge,
      tag: notificationData.tag,
      data: notificationData.data,
      requireInteraction: notificationData.requireInteraction || false,
      actions: notificationData.actions || [
        {
          action: 'view',
          title: 'üëÄ Ver detalles',
          icon: '/assets/icons/view-icon.png'
        },
        {
          action: 'dismiss',
          title: '‚ùå Descartar',
          icon: '/assets/icons/dismiss-icon.png'
        }
      ],
      vibrate: notificationData.vibrate || [200, 100, 200],
      silent: notificationData.silent || false
    })
  );
});

// Manejar clicks en notificaciones
self.addEventListener('notificationclick', (event) => {
  console.log('Service Worker: Click en notificaci√≥n:', event);
  
  event.notification.close();

  const action = event.action;
  const notificationData = event.notification.data || {};
  
  if (action === 'dismiss') {
    // Solo cerrar la notificaci√≥n
    return;
  }

  // Determinar URL de destino
  let targetUrl = '/';
  
  if (action === 'view' || !action) {
    targetUrl = notificationData.url || '/tarjetas';
  }

  // Abrir o enfocar la aplicaci√≥n
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Buscar si ya hay una ventana abierta
        for (const client of clientList) {
          if (client.url.includes(self.location.origin)) {
            // Navegar a la URL objetivo y enfocar
            client.navigate(targetUrl);
            return client.focus();
          }
        }
        
        // Si no hay ventana abierta, abrir una nueva
        return clients.openWindow(targetUrl);
      })
      .catch((error) => {
        console.error('Service Worker: Error manejando click:', error);
      })
  );
});

// Manejar cierre de notificaciones
self.addEventListener('notificationclose', (event) => {
  console.log('Service Worker: Notificaci√≥n cerrada:', event.notification.tag);
  
  // Aqu√≠ se podr√≠a enviar analytics o limpiar datos relacionados
  const notificationData = event.notification.data || {};
  
  if (notificationData.trackClose) {
    // Enviar evento de tracking si es necesario
    console.log('Tracking: Notificaci√≥n cerrada sin interacci√≥n');
  }
});

// Manejar errores del Service Worker
self.addEventListener('error', (event) => {
  console.error('Service Worker: Error:', event.error);
});

// Manejar errores no capturados
self.addEventListener('unhandledrejection', (event) => {
  console.error('Service Worker: Promise rechazada:', event.reason);
  event.preventDefault();
});

// Background Sync para verificaci√≥n de vencimientos offline
self.addEventListener('sync', (event) => {
  console.log('Service Worker: Background Sync activado:', event.tag);
  
  if (event.tag === 'verificar-vencimientos') {
    event.waitUntil(verificarVencimientosOffline());
  }
  
  if (event.tag === 'enviar-notificaciones-pendientes') {
    event.waitUntil(enviarNotificacionesPendientes());
  }
});

// Funci√≥n para verificar vencimientos en modo offline
async function verificarVencimientosOffline() {
  try {
    const ahora = new Date();
    console.log(`üîÑ Service Worker: Verificando vencimientos offline a las ${ahora.getHours()}:${ahora.getMinutes().toString().padStart(2, '0')}`);
    
    // Obtener datos desde IndexedDB o cache
    const tarjetas = await obtenerTarjetasDesdeCache();
    const configuracion = await obtenerConfiguracionDesdeCache();
    
    console.log('üìä Service Worker: Datos obtenidos:', {
      tarjetas: tarjetas ? tarjetas.length : 0,
      configuracion: configuracion ? 'S√≠' : 'No'
    });
    
    if (!tarjetas || !configuracion) {
      console.log('‚ùå Service Worker: No hay datos suficientes para verificar offline');
      return;
    }
    
    console.log(`‚öôÔ∏è Service Worker: Configuraci√≥n - Hora: ${configuracion.horaNotificacion}, D√≠as anticipaci√≥n: ${configuracion.diasAnticipacion}`);
    
    const tarjetasVencidas = [];
    
    // Verificar cada tarjeta
    for (const tarjeta of tarjetas) {
      if (!tarjeta.fechaVencimiento) continue;
      
      const fechaVencimiento = new Date(tarjeta.fechaVencimiento);
      const diasHastaVencimiento = Math.ceil((fechaVencimiento.getTime() - ahora.getTime()) / (1000 * 60 * 60 * 24));
      
      console.log(`üí≥ Service Worker: Tarjeta ${tarjeta.nombre} - D√≠as hasta vencimiento: ${diasHastaVencimiento}`);
      
      // Verificar si debe notificar seg√∫n configuraci√≥n
      if (diasHastaVencimiento <= configuracion.diasAnticipacion && diasHastaVencimiento >= 0) {
        console.log(`‚è∞ Service Worker: Verificando hora para ${tarjeta.nombre}`);
        
        // Verificar si es la hora correcta
        if (esHoraCorrecta(ahora, configuracion.horaNotificacion)) {
          console.log(`‚úÖ Service Worker: Hora correcta para ${tarjeta.nombre}`);
          tarjetasVencidas.push({
            ...tarjeta,
            diasHastaVencimiento
          });
        } else {
          console.log(`‚ùå Service Worker: Hora incorrecta para ${tarjeta.nombre}`);
        }
      }
    }
    
    // Enviar notificaciones para tarjetas vencidas
    for (const tarjeta of tarjetasVencidas) {
      console.log(`üîî Service Worker: Enviando notificaci√≥n para ${tarjeta.nombre}`);
      await enviarNotificacionVencimientoOffline(tarjeta);
    }
    
    console.log(`‚úÖ Service Worker: Verificaci√≥n offline completada. ${tarjetasVencidas.length} notificaciones enviadas`);
    
  } catch (error) {
    console.error('‚ùå Service Worker: Error en verificaci√≥n offline:', error);
  }
}

// Funci√≥n para enviar notificaciones pendientes
async function enviarNotificacionesPendientes() {
  try {
    console.log('Service Worker: Enviando notificaciones pendientes...');
    
    const notificacionesPendientes = await obtenerNotificacionesPendientes();
    
    for (const notificacion of notificacionesPendientes) {
      await self.registration.showNotification(notificacion.title, notificacion.options);
      await marcarNotificacionComoEnviada(notificacion.id);
    }
    
    console.log(`Service Worker: ${notificacionesPendientes.length} notificaciones pendientes enviadas`);
    
  } catch (error) {
    console.error('Service Worker: Error enviando notificaciones pendientes:', error);
  }
}

// Funci√≥n para verificar si es la hora correcta
function esHoraCorrecta(ahora, horaConfiguracion) {
  const [horaConfig, minutoConfig] = horaConfiguracion.split(':').map(Number);
  const horaActual = ahora.getHours();
  const minutoActual = ahora.getMinutes();
  
  // Ventana de 5 minutos
  const minutosConfig = horaConfig * 60 + minutoConfig;
  const minutosActuales = horaActual * 60 + minutoActual;
  const diferencia = Math.abs(minutosActuales - minutosConfig);
  const esHoraCorrecta = diferencia <= 5;
  
  console.log(`üïê Service Worker: Verificaci√≥n de hora - Actual: ${horaActual}:${minutoActual.toString().padStart(2, '0')}, Configurada: ${horaConfig}:${minutoConfig.toString().padStart(2, '0')}, Diferencia: ${diferencia} min, Es correcta: ${esHoraCorrecta}`);
  
  return esHoraCorrecta;
}

// Funci√≥n para enviar notificaci√≥n de vencimiento offline
async function enviarNotificacionVencimientoOffline(tarjeta) {
  const notificationData = generarNotificacionVencimiento({
    nombreTarjeta: tarjeta.nombre,
    diasHastaVencimiento: tarjeta.diasHastaVencimiento,
    montoAdeudado: tarjeta.montoAdeudado || 0,
    tarjetaId: tarjeta.id
  });
  
  await self.registration.showNotification(notificationData.title, {
    body: notificationData.body,
    icon: notificationData.icon,
    badge: notificationData.badge,
    tag: notificationData.tag,
    data: notificationData.data,
    requireInteraction: notificationData.requireInteraction,
    actions: notificationData.actions,
    vibrate: notificationData.vibrate,
    silent: notificationData.silent
  });
}

// Funci√≥n helper para generar notificaciones de vencimiento
function generarNotificacionVencimiento(datosVencimiento) {
  const { nombreTarjeta, diasHastaVencimiento, montoAdeudado, tarjetaId } = datosVencimiento;
  
  const esUrgente = diasHastaVencimiento === 0;
  const esCercano = diasHastaVencimiento <= 1;
  
  return {
    title: `üí≥ ${nombreTarjeta} ${esUrgente ? 'vence HOY' : `vence en ${diasHastaVencimiento} d√≠as`}`,
    body: `Monto a pagar: $${montoAdeudado.toLocaleString('es-AR')}`,
    icon: '/assets/icons/icon-192x192.png',
    badge: '/assets/icons/badge-72x72.png',
    tag: `vencimiento-${tarjetaId}`,
    requireInteraction: esUrgente,
    data: {
      tipo: 'vencimiento',
      tarjetaId: tarjetaId,
      url: '/tarjetas',
      trackClose: true
    },
    actions: [
      {
        action: 'view',
        title: 'üëÄ Ver tarjeta',
        icon: '/assets/icons/view-icon.png'
      },
      {
        action: 'remind',
        title: '‚è∞ Recordar m√°s tarde',
        icon: '/assets/icons/remind-icon.png'
      }
    ],
    vibrate: esUrgente ? [300, 100, 300, 100, 300] : [200, 100, 200],
    silent: false
  };
}

// Funciones auxiliares para manejo de datos offline
async function obtenerTarjetasDesdeCache() {
  try {
    // Intentar obtener desde IndexedDB primero
    const tarjetas = await obtenerDesdeIndexedDB('tarjetas');
    if (tarjetas) {
      return tarjetas;
    }
    
    // Fallback: obtener desde localStorage si est√° disponible
    if (typeof localStorage !== 'undefined') {
      const tarjetasStr = localStorage.getItem('gestor_tc_tarjetas');
      return tarjetasStr ? JSON.parse(tarjetasStr) : null;
    }
    
    return null;
  } catch (error) {
    console.error('Service Worker: Error obteniendo tarjetas desde cache:', error);
    return null;
  }
}

async function obtenerConfiguracionDesdeCache() {
  try {
    // Intentar obtener desde IndexedDB primero (configuraci√≥n principal)
    let config = await obtenerDesdeIndexedDB('configuracion');
    if (config) {
      console.log('üìã SW: Configuraci√≥n obtenida desde store principal:', config.horaNotificacion);
      return config;
    }
    
    // NUEVO: Fallback a configuraci√≥n de notificaciones
    config = await obtenerDesdeIndexedDB('configuracion-notificaciones');
    if (config) {
      console.log('üìã SW: Configuraci√≥n obtenida desde store de notificaciones:', config.horaNotificacion);
      // Convertir formato de NotificacionService a formato esperado
      return {
        diasAnticipacion: config.diasAnticipacion || 3,
        horaNotificacion: config.horaNotificacion || '09:00',
        emailNotificaciones: config.emailHabilitado || false,
        pushNotificaciones: config.pushHabilitado || true,
        emailDestino: config.emailDestino
      };
    }
    
    // Fallback final: configuraci√≥n por defecto
    console.log('üìã SW: Usando configuraci√≥n por defecto');
    return {
      diasAnticipacion: 3,
      horaNotificacion: '09:00',
      emailNotificaciones: true,
      pushNotificaciones: true
    };
  } catch (error) {
    console.error('Service Worker: Error obteniendo configuraci√≥n desde cache:', error);
    return {
      diasAnticipacion: 3,
      horaNotificacion: '09:00',
      emailNotificaciones: true,
      pushNotificaciones: true
    };
  }
}

async function obtenerNotificacionesPendientes() {
  try {
    const pendientes = await obtenerDesdeIndexedDB('notificaciones_pendientes');
    return pendientes || [];
  } catch (error) {
    console.error('Service Worker: Error obteniendo notificaciones pendientes:', error);
    return [];
  }
}

async function marcarNotificacionComoEnviada(notificacionId) {
  try {
    const pendientes = await obtenerNotificacionesPendientes();
    const nuevasPendientes = pendientes.filter(n => n.id !== notificacionId);
    await guardarEnIndexedDB('notificaciones_pendientes', nuevasPendientes);
  } catch (error) {
    console.error('Service Worker: Error marcando notificaci√≥n como enviada:', error);
  }
}

// Funciones para IndexedDB
async function obtenerDesdeIndexedDB(store) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('GestorTCDB', 4);
    
    request.onerror = () => reject(request.error);
    
    request.onsuccess = () => {
      const db = request.result;
      
      if (!db.objectStoreNames.contains(store)) {
        db.close();
        resolve(null);
        return;
      }
      
      const transaction = db.transaction([store], 'readonly');
      const objectStore = transaction.objectStore(store);
      const getRequest = objectStore.get('data');
      
      getRequest.onsuccess = () => {
        db.close();
        resolve(getRequest.result ? getRequest.result.value : null);
      };
      
      getRequest.onerror = () => {
        db.close();
        reject(getRequest.error);
      };
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Crear todos los object stores necesarios
      const requiredStores = [
        'configuracion',
        'tarjetas',
        'notificaciones_pendientes',
        'gastos'
      ];
      
      requiredStores.forEach(storeName => {
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName);
        }
      });
      
      // Tambi√©n crear el store solicitado si no existe
      if (!db.objectStoreNames.contains(store)) {
        db.createObjectStore(store);
      }
    };
  });
}

async function guardarEnIndexedDB(store, data) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('GestorTCDB', 4);
    
    request.onerror = () => reject(request.error);
    
    request.onsuccess = () => {
      const db = request.result;
      
      // Verificar si el object store existe antes de crear la transacci√≥n
      if (!db.objectStoreNames.contains(store)) {
        // Si el store no existe, cerrar la conexi√≥n y forzar upgrade
        db.close();
        const upgradeRequest = indexedDB.open('GestorTCDB', db.version + 1);
        
        upgradeRequest.onupgradeneeded = (event) => {
          const upgradeDb = event.target.result;
          if (!upgradeDb.objectStoreNames.contains(store)) {
            upgradeDb.createObjectStore(store);
          }
        };
        
        upgradeRequest.onsuccess = () => {
          const upgradeDb = upgradeRequest.result;
          const transaction = upgradeDb.transaction([store], 'readwrite');
          const objectStore = transaction.objectStore(store);
          const putRequest = objectStore.put({ value: data }, 'data');
          
          putRequest.onsuccess = () => {
            upgradeDb.close();
            resolve();
          };
          putRequest.onerror = () => {
            upgradeDb.close();
            reject(putRequest.error);
          };
        };
        
        upgradeRequest.onerror = () => reject(upgradeRequest.error);
      } else {
        const transaction = db.transaction([store], 'readwrite');
        const objectStore = transaction.objectStore(store);
        const putRequest = objectStore.put({ value: data }, 'data');
        
        putRequest.onsuccess = () => {
          db.close();
          resolve();
        };
        putRequest.onerror = () => {
          db.close();
          reject(putRequest.error);
        };
      }
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Crear todos los object stores necesarios
      const requiredStores = [
        'configuracion',
        'tarjetas',
        'notificaciones_pendientes',
        'gastos'
      ];
      
      requiredStores.forEach(storeName => {
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName);
        }
      });
      
      // Tambi√©n crear el store din√°mico si no existe
      if (!db.objectStoreNames.contains(store)) {
        db.createObjectStore(store);
      }
    };
  });
}

// Escuchar mensajes desde la aplicaci√≥n principal
self.addEventListener('message', event => {
  const { type, payload } = event.data;
  
  switch (type) {
    case 'SCHEDULE_SYNC':
      // Programar una sincronizaci√≥n
      if (payload.tag) {
        self.registration.sync.register(payload.tag)
          .then(() => console.log(`üîÑ Sync programado: ${payload.tag}`))
          .catch(err => console.error('‚ùå Error programando sync:', err));
      }
      break;
      
    case 'SAVE_DATA':
      // Guardar datos en IndexedDB
      if (payload.key && payload.data) {
        console.log(`üìù Service Worker: Guardando ${payload.key}:`, payload.data);
        guardarEnIndexedDB(payload.key, payload.data)
          .then(() => {
            console.log(`üíæ Datos guardados exitosamente: ${payload.key}`);
            if (payload.key === 'configuracion') {
              console.log(`‚öôÔ∏è Configuraci√≥n guardada - Hora: ${payload.data.horaNotificacion}`);
            }
          })
          .catch(err => console.error('‚ùå Error guardando datos:', err));
      }
      break;
      
    case 'SCHEDULE_NOTIFICATION':
      // Programar una notificaci√≥n
      programarNotificacion(payload)
        .then(() => console.log(`üîî Notificaci√≥n programada: ${payload.id}`))
        .catch(err => console.error('‚ùå Error programando notificaci√≥n:', err));
      break;
      
    case 'CANCEL_NOTIFICATION':
      // Cancelar notificaci√≥n programada
      cancelarNotificacionProgramada(payload.tag)
        .then(() => console.log(`üö´ Notificaci√≥n cancelada: ${payload.tag}`))
        .catch(err => console.error('‚ùå Error cancelando notificaci√≥n:', err));
      break;
      
    case 'FORCE_CHECK_VENCIMIENTOS':
      // Forzar verificaci√≥n manual de vencimientos
      console.log('üîß Service Worker: Forzando verificaci√≥n de vencimientos...');
      verificarVencimientosOffline()
        .then(() => console.log('‚úÖ Service Worker: Verificaci√≥n forzada completada'))
        .catch(err => console.error('‚ùå Error en verificaci√≥n forzada:', err));
      break;
      
    case 'SKIP_WAITING':
      // Activar inmediatamente el Service Worker
      console.log('üöÄ Service Worker: Activando inmediatamente...');
      self.skipWaiting();
      break;
      
    case 'DEBUG_CONFIG':
      // Debug: mostrar configuraci√≥n actual en IndexedDB
      console.log('üîç Service Worker: Verificando configuraci√≥n en IndexedDB...');
      Promise.all([
        obtenerDesdeIndexedDB('configuracion'),
        obtenerDesdeIndexedDB('configuracion-notificaciones')
      ])
        .then(([configPrincipal, configNotificaciones]) => {
          console.log('üîç SW: Configuraciones en IndexedDB:');
          console.log('üìã Store "configuracion":', configPrincipal);
          console.log('üìã Store "configuracion-notificaciones":', configNotificaciones);
          
          const configFinal = configPrincipal || configNotificaciones || {
            diasAnticipacion: 3,
            horaNotificacion: '09:00',
            emailNotificaciones: true,
            pushNotificaciones: true
          };
          
          console.log('‚öôÔ∏è SW: Configuraci√≥n final utilizada:', configFinal);
          
          // Enviar respuesta de vuelta
          event.ports[0]?.postMessage({
            type: 'DEBUG_CONFIG_RESPONSE',
            config: {
              principal: configPrincipal,
              notificaciones: configNotificaciones,
              final: configFinal
            }
          });
        })
        .catch(err => {
          console.error('‚ùå Error obteniendo configuraci√≥n para debug:', err);
          event.ports[0]?.postMessage({ success: false, error: err.message });
        });
      break;
  }
});

/**
 * Programa una notificaci√≥n para env√≠o posterior
 */
async function programarNotificacion(payload) {
  try {
    const { datos, fechaEnvio, id } = payload;
    const ahora = Date.now();
    const tiempoEspera = fechaEnvio - ahora;
    
    if (tiempoEspera <= 0) {
      // Enviar inmediatamente si ya es hora
      await mostrarNotificacionVencimiento(datos);
      return;
    }
    
    // Guardar la notificaci√≥n programada
    const notificacionProgramada = {
      id,
      datos,
      fechaEnvio,
      programadaEn: ahora
    };
    
    await guardarEnIndexedDB(`notificacion_${id}`, notificacionProgramada);
    
    // Programar un timeout (limitado a 24 horas por las limitaciones del navegador)
    const tiempoMaximo = Math.min(tiempoEspera, 24 * 60 * 60 * 1000); // 24 horas m√°ximo
    
    setTimeout(async () => {
      try {
        const notificacion = await obtenerDesdeIndexedDB(`notificacion_${id}`);
        if (notificacion && Date.now() >= notificacion.fechaEnvio) {
          await mostrarNotificacionVencimiento(notificacion.datos);
          await eliminarDeIndexedDB(`notificacion_${id}`);
        }
      } catch (error) {
        console.error('Error ejecutando notificaci√≥n programada:', error);
      }
    }, tiempoMaximo);
    
  } catch (error) {
    console.error('Error programando notificaci√≥n:', error);
    throw error;
  }
}

/**
 * Cancela una notificaci√≥n programada
 */
async function cancelarNotificacionProgramada(tag) {
  try {
    // Buscar y eliminar notificaciones con el tag especificado
    const keys = await obtenerClavesIndexedDB();
    const notificacionesACancelar = keys.filter(key => 
      key.startsWith('notificacion_') && key.includes(tag)
    );
    
    for (const key of notificacionesACancelar) {
      await eliminarDeIndexedDB(key);
    }
    
    console.log(`Canceladas ${notificacionesACancelar.length} notificaciones con tag: ${tag}`);
  } catch (error) {
    console.error('Error cancelando notificaciones:', error);
    throw error;
  }
}

/**
 * Muestra una notificaci√≥n de vencimiento
 */
async function mostrarNotificacionVencimiento(datos) {
  try {
    const notificacion = generarNotificacionVencimiento(datos);
    
    await self.registration.showNotification(notificacion.title, {
      body: notificacion.body,
      icon: notificacion.icon,
      badge: notificacion.badge,
      tag: notificacion.tag,
      data: notificacion.data,
      actions: notificacion.actions,
      vibrate: notificacion.vibrate,
      requireInteraction: true,
      silent: false
    });
    
    console.log('Notificaci√≥n de vencimiento mostrada:', datos.nombreTarjeta);
  } catch (error) {
    console.error('Error mostrando notificaci√≥n de vencimiento:', error);
    throw error;
  }
}

/**
 * Elimina un elemento de IndexedDB
 */
async function eliminarDeIndexedDB(key) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('GestorTCDB', 4);
    
    request.onsuccess = () => {
      const db = request.result;
      const transaction = db.transaction(['notificaciones'], 'readwrite');
      const store = transaction.objectStore('notificaciones');
      
      const deleteRequest = store.delete(key);
      
      deleteRequest.onsuccess = () => resolve();
      deleteRequest.onerror = () => reject(deleteRequest.error);
    };
    
    request.onerror = () => reject(request.error);
  });
}

/**
 * Obtiene todas las claves de IndexedDB
 */
async function obtenerClavesIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('GestorTCDB', 4);
    
    request.onsuccess = () => {
      const db = request.result;
      const transaction = db.transaction(['notificaciones'], 'readonly');
      const store = transaction.objectStore('notificaciones');
      
      const getAllKeysRequest = store.getAllKeys();
      
      getAllKeysRequest.onsuccess = () => resolve(getAllKeysRequest.result);
      getAllKeysRequest.onerror = () => reject(getAllKeysRequest.error);
    };
    
    request.onerror = () => reject(request.error);
  });
}

// Exportar funciones para uso en otros contextos si es necesario
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    generarNotificacionVencimiento,
    obtenerTarjetasDesdeCache,
    obtenerConfiguracionDesdeCache
  };
}
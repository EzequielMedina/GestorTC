// Script espec√≠fico para verificar IndexedDB y sincronizaci√≥n
// Ejecutar en DevTools Console despu√©s de cargar la aplicaci√≥n

const VerificarIndexedDB = {
  async ejecutarDiagnosticoCompleto() {
    console.log('üîç DIAGN√ìSTICO COMPLETO DE INDEXEDDB Y SINCRONIZACI√ìN');
    console.log('=======================================================');
    
    // 1. Verificar si IndexedDB existe
    await this.verificarExistenciaIndexedDB();
    
    // 2. Intentar crear IndexedDB manualmente
    await this.crearIndexedDBManual();
    
    // 3. Verificar sincronizaci√≥n
    await this.verificarSincronizacion();
    
    // 4. Probar guardado manual
    await this.probarGuardadoManual();
    
    // 5. Verificar Service Worker
    await this.verificarServiceWorker();
    
    console.log('\n‚úÖ Diagn√≥stico completo finalizado');
  },

  async verificarExistenciaIndexedDB() {
    console.log('\nüìä 1. VERIFICANDO EXISTENCIA DE INDEXEDDB:');
    
    try {
      // Listar todas las bases de datos
      if ('databases' in indexedDB) {
        const databases = await indexedDB.databases();
        console.log('üìã Bases de datos existentes:', databases.map(db => db.name));
        
        const gestorDB = databases.find(db => db.name === 'GestorTCDB');
        if (gestorDB) {
          console.log('‚úÖ GestorTCDB encontrada, versi√≥n:', gestorDB.version);
        } else {
          console.log('‚ùå GestorTCDB NO encontrada');
        }
      } else {
        console.log('‚ö†Ô∏è indexedDB.databases() no soportado');
      }
      
      // Intentar abrir la base de datos
      const db = await this.abrirDB();
      if (db) {
        console.log('‚úÖ Conexi√≥n a GestorTCDB exitosa');
        console.log('üìã Object stores:', Array.from(db.objectStoreNames));
        db.close();
      }
    } catch (error) {
      console.log('‚ùå Error verificando IndexedDB:', error);
    }
  },

  async abrirDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('GestorTCDB', 4);
      
      request.onsuccess = () => {
        resolve(request.result);
      };
      
      request.onerror = () => {
        console.log('‚ùå Error abriendo DB:', request.error);
        resolve(null);
      };
      
      request.onupgradeneeded = (event) => {
        console.log('üîß DB necesita actualizaci√≥n, versi√≥n:', event.oldVersion, '->', event.newVersion);
        const db = event.target.result;
        
        // Crear stores si no existen
        if (!db.objectStoreNames.contains('configuracion')) {
          db.createObjectStore('configuracion');
          console.log('üì¶ Store "configuracion" creado');
        }
        
        if (!db.objectStoreNames.contains('configuracion-notificaciones')) {
          db.createObjectStore('configuracion-notificaciones');
          console.log('üì¶ Store "configuracion-notificaciones" creado');
        }
        
        if (!db.objectStoreNames.contains('tarjetas')) {
          db.createObjectStore('tarjetas');
          console.log('üì¶ Store "tarjetas" creado');
        }
      };
    });
  },

  async crearIndexedDBManual() {
    console.log('\nüîß 2. CREANDO INDEXEDDB MANUALMENTE:');
    
    try {
      const db = await new Promise((resolve, reject) => {
        const request = indexedDB.open('GestorTCDB', 4);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          
          // Crear stores necesarios
          const stores = ['configuracion', 'configuracion-notificaciones', 'tarjetas'];
          
          stores.forEach(storeName => {
            if (!db.objectStoreNames.contains(storeName)) {
              db.createObjectStore(storeName);
              console.log(`üì¶ Store "${storeName}" creado`);
            }
          });
        };
      });
      
      console.log('‚úÖ IndexedDB creada/verificada exitosamente');
      console.log('üìã Stores disponibles:', Array.from(db.objectStoreNames));
      db.close();
      
    } catch (error) {
      console.log('‚ùå Error creando IndexedDB:', error);
    }
  },

  async verificarSincronizacion() {
    console.log('\nüîÑ 3. VERIFICANDO SINCRONIZACI√ìN:');
    
    // Verificar localStorage
    const configUsuario = localStorage.getItem('gestor-tc-config-usuario');
    const configNotificaciones = localStorage.getItem('gestor-tc-config-notificaciones');
    
    console.log('üì± localStorage:');
    console.log('  - gestor-tc-config-usuario:', configUsuario ? 'EXISTS' : 'MISSING');
    console.log('  - gestor-tc-config-notificaciones:', configNotificaciones ? 'EXISTS' : 'MISSING');
    
    if (configUsuario) {
      const config = JSON.parse(configUsuario);
      console.log('  - Hora configurada:', config.tiempos?.horaNotificacion || 'NO DEFINIDA');
    }
    
    // Verificar IndexedDB
    try {
      const db = await this.abrirDB();
      if (db) {
        const configDB = await this.leerStore(db, 'configuracion');
        const notifDB = await this.leerStore(db, 'configuracion-notificaciones');
        
        console.log('üíæ IndexedDB:');
        console.log('  - configuracion:', configDB ? 'EXISTS' : 'MISSING');
        console.log('  - configuracion-notificaciones:', notifDB ? 'EXISTS' : 'MISSING');
        
        if (configDB && configDB.length > 0) {
          console.log('  - Datos en configuracion:', configDB[0]);
        }
        
        if (notifDB && notifDB.length > 0) {
          console.log('  - Datos en configuracion-notificaciones:', notifDB[0]);
        }
        
        db.close();
      }
    } catch (error) {
      console.log('‚ùå Error verificando IndexedDB:', error);
    }
  },

  async leerStore(db, storeName) {
    return new Promise((resolve, reject) => {
      try {
        const transaction = db.transaction([storeName], 'readonly');
        const store = transaction.objectStore(storeName);
        const request = store.getAll();
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      } catch (error) {
        resolve(null);
      }
    });
  },

  async probarGuardadoManual() {
    console.log('\nüíæ 4. PROBANDO GUARDADO MANUAL:');
    
    try {
      const db = await this.abrirDB();
      if (db) {
        // Probar guardado en store configuracion
        const configTest = {
          horaNotificacion: '15:30',
          diasAnticipacion: 3,
          emailNotificaciones: true,
          pushNotificaciones: true,
          timestamp: new Date().toISOString()
        };
        
        await this.guardarEnStore(db, 'configuracion', 'test-config', configTest);
        console.log('‚úÖ Guardado en store "configuracion" exitoso');
        
        // Verificar que se guard√≥
        const verificacion = await this.leerStore(db, 'configuracion');
        console.log('üìã Verificaci√≥n de guardado:', verificacion);
        
        db.close();
      }
    } catch (error) {
      console.log('‚ùå Error en guardado manual:', error);
    }
  },

  async guardarEnStore(db, storeName, key, data) {
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      const request = store.put(data, key);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },

  async verificarServiceWorker() {
    console.log('\nüîß 5. VERIFICANDO SERVICE WORKER:');
    
    if ('serviceWorker' in navigator) {
      const registration = await navigator.serviceWorker.getRegistration();
      
      if (registration) {
        console.log('‚úÖ Service Worker registrado');
        console.log('üìã Estado:', registration.active?.state);
        console.log('üìã Scope:', registration.scope);
        
        // Probar comunicaci√≥n con SW
        if (registration.active) {
          console.log('üîÑ Probando comunicaci√≥n con SW...');
          
          try {
            // Enviar mensaje de prueba
            const channel = new MessageChannel();
            const response = await new Promise((resolve, reject) => {
              channel.port1.onmessage = (event) => {
                resolve(event.data);
              };
              
              registration.active.postMessage({
                type: 'DEBUG_CONFIG'
              }, [channel.port2]);
              
              setTimeout(() => reject(new Error('Timeout')), 5000);
            });
            
            console.log('‚úÖ Comunicaci√≥n con SW exitosa:', response);
          } catch (error) {
            console.log('‚ùå Error comunic√°ndose con SW:', error);
          }
        }
      } else {
        console.log('‚ùå Service Worker no registrado');
      }
    } else {
      console.log('‚ùå Service Worker no soportado');
    }
  },

  // Funci√≥n para forzar sincronizaci√≥n completa
  async forzarSincronizacionCompleta() {
    console.log('\nüîÑ FORZANDO SINCRONIZACI√ìN COMPLETA:');
    
    try {
      // 1. Obtener configuraci√≥n actual de localStorage
      const configUsuario = localStorage.getItem('gestor-tc-config-usuario');
      const configNotificaciones = localStorage.getItem('gestor-tc-config-notificaciones');
      
      if (configUsuario || configNotificaciones) {
        // 2. Enviar al Service Worker
        if (window.backgroundSyncService) {
          console.log('üîÑ Usando BackgroundSyncService...');
          await window.backgroundSyncService.sincronizarManualmente();
        } else {
          console.log('üîÑ Enviando directamente al SW...');
          const registration = await navigator.serviceWorker.getRegistration();
          
          if (registration?.active) {
            if (configUsuario) {
              registration.active.postMessage({
                type: 'SAVE_DATA',
                payload: {
                  key: 'configuracion',
                  data: JSON.parse(configUsuario)
                }
              });
            }
            
            if (configNotificaciones) {
              registration.active.postMessage({
                type: 'SAVE_DATA',
                payload: {
                  key: 'configuracion-notificaciones',
                  data: JSON.parse(configNotificaciones)
                }
              });
            }
          }
        }
        
        console.log('‚úÖ Sincronizaci√≥n forzada enviada');
        
        // 3. Esperar un momento y verificar
        setTimeout(async () => {
          await this.verificarSincronizacion();
        }, 2000);
        
      } else {
        console.log('‚ö†Ô∏è No hay configuraci√≥n en localStorage para sincronizar');
      }
    } catch (error) {
      console.log('‚ùå Error forzando sincronizaci√≥n:', error);
    }
  }
};

// Ejecutar diagn√≥stico autom√°ticamente
console.log('üöÄ Iniciando verificaci√≥n de IndexedDB...');
VerificarIndexedDB.ejecutarDiagnosticoCompleto();

// Exponer funciones globalmente
window.VerificarIndexedDB = VerificarIndexedDB;
window.verificarIndexedDB = () => VerificarIndexedDB.ejecutarDiagnosticoCompleto();
window.forzarSincronizacionCompleta = () => VerificarIndexedDB.forzarSincronizacionCompleta();

console.log('\nüìù FUNCIONES ADICIONALES DISPONIBLES:');
console.log('- verificarIndexedDB() - Ejecutar verificaci√≥n completa');
console.log('- forzarSincronizacionCompleta() - Forzar sincronizaci√≥n desde localStorage');
console.log('- VerificarIndexedDB.* - Acceso a todas las funciones espec√≠ficas');